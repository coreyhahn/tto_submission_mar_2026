`default_nettype none

// Auto-generated by scripts/gen_secded.py â€” do not edit
// (265, 256) Hamming SECDED correction module
//
// Syndrome = received_check XOR computed_check
// If syndrome matches a data position (non-power-of-2, 1..265): single error, correct it
// If syndrome matches a check position (power-of-2): single error in check bit, no data fix
// If syndrome > 265: multi-bit error detected

module secded_correct (
    input  wire [255:0] data_in,
    input  wire [8:0]   check_in,    // Received check bits
    input  wire [8:0]   check_calc,  // Calculated check bits (from secded_parity)
    output wire [255:0] data_out,
    output wire         sec_flag,    // Single error corrected
    output wire         ded_flag     // Double error detected
);

    wire [8:0] syndrome = check_in ^ check_calc;

    // Priority encoder: find position of highest set bit in syndrome
    reg [3:0] highest_bit;
    always @(*) begin
        casez (syndrome)
            9'b1????????: highest_bit = 4'd8;
            9'b01???????: highest_bit = 4'd7;
            9'b001??????: highest_bit = 4'd6;
            9'b0001?????: highest_bit = 4'd5;
            9'b00001????: highest_bit = 4'd4;
            9'b000001???: highest_bit = 4'd3;
            9'b0000001??: highest_bit = 4'd2;
            9'b00000001?: highest_bit = 4'd1;
            9'b000000001: highest_bit = 4'd0;
            default:      highest_bit = 4'd0;
        endcase
    end

    // Power-of-2 detection (check bit error positions)
    wire is_pow2 = |syndrome && ((syndrome & (syndrome - 9'd1)) == 9'd0);

    // Range check: valid single-error positions are 1..265
    wire in_range = |syndrome && (syndrome <= 9'd265);

    // Data error: non-zero syndrome in range, not a check bit position
    wire is_data_err = in_range && !is_pow2;

    // Check error: non-zero syndrome in range, at a check bit position
    wire is_check_err = in_range && is_pow2;

    // Convert syndrome (codeword position) to data bit index (0..255)
    // Formula: data_idx = syndrome - 2 - highest_bit_pos
    // (subtracts 1 for zero-indexing and (highest_bit+1) for skipped power-of-2 positions)
    wire [8:0] data_idx = syndrome - {5'd0, highest_bit} - 9'd2;

    // Decomposed one-hot decoder: two 4-to-16 decoders
    wire [15:0] dec_lo = is_data_err ? (16'd1 << data_idx[3:0]) : 16'd0;
    wire [15:0] dec_hi = is_data_err ? (16'd1 << data_idx[7:4]) : 16'd0;

    // 256-bit flip mask from decomposed decoders
    wire [255:0] flip_mask;
    genvar gi, gj;
    generate
        for (gi = 0; gi < 16; gi = gi + 1) begin : gen_hi
            for (gj = 0; gj < 16; gj = gj + 1) begin : gen_lo
                assign flip_mask[gi * 16 + gj] = dec_hi[gi] & dec_lo[gj];
            end
        end
    endgenerate

    assign data_out = data_in ^ flip_mask;

    // SEC: any correctable single-bit error (data or check bit)
    assign sec_flag = is_data_err || is_check_err;

    // DED: non-zero syndrome outside valid range (multi-bit error)
    assign ded_flag = |syndrome && !in_range;

endmodule
