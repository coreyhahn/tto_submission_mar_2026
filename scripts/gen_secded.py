#!/usr/bin/env python3
"""
Generate SECDED Hamming code modules for 256-bit data, 9 check bits.

Uses standard (265, 256) Hamming code with check bits at power-of-2 positions.
Positions 1..265 total: 9 check positions (1,2,4,8,16,32,64,128,256),
256 data positions (all non-power-of-2 positions).

For each check bit j at position 2^j, it covers all codeword positions
where bit j of the position number is 1.

SEC: non-zero syndrome in range 1..265 -> correctable single error
DED: non-zero syndrome > 265 -> detected double error (partial coverage)
"""

import os

def is_power_of_two(n):
    return n > 0 and (n & (n - 1)) == 0

def generate_mapping():
    """Map data bit index (0..255) to codeword position (skip powers of 2)."""
    data_to_pos = []
    pos = 1
    while len(data_to_pos) < 256:
        if not is_power_of_two(pos):
            data_to_pos.append(pos)
        pos += 1
    assert len(data_to_pos) == 256
    assert data_to_pos[-1] == 265
    return data_to_pos

def compute_masks(data_to_pos):
    """For each of 9 check bits, compute a 256-bit mask of covered data bits."""
    masks = []
    for j in range(9):
        mask = 0
        for i in range(256):
            if data_to_pos[i] & (1 << j):
                mask |= (1 << i)
        masks.append(mask)
    return masks

def gen_secded_parity_v(masks):
    """Generate secded_parity.v: 256-bit data -> 9-bit check bits."""
    lines = []
    lines.append("`default_nettype none")
    lines.append("")
    lines.append("// Auto-generated by scripts/gen_secded.py — do not edit")
    lines.append("// (265, 256) Hamming code parity calculator")
    lines.append("// 9 check bits at positions 1,2,4,8,16,32,64,128,256")
    lines.append("")
    lines.append("module secded_parity (")
    lines.append("    input  wire [255:0] data,")
    lines.append("    output wire [8:0]   check")
    lines.append(");")
    lines.append("")

    for j in range(9):
        mask = masks[j]
        popcount = bin(mask).count('1')
        lines.append(f"    // Check bit {j} (position {1<<j}): covers {popcount} data bits")
        lines.append(f"    localparam [255:0] MASK_{j} = 256'h{mask:064x};")
        lines.append(f"    assign check[{j}] = ^(data & MASK_{j});")
        lines.append("")

    lines.append("endmodule")
    return "\n".join(lines) + "\n"

def gen_secded_correct_v():
    """Generate secded_correct.v: syndrome-based correction with decomposed decoder."""
    return """\
`default_nettype none

// Auto-generated by scripts/gen_secded.py — do not edit
// (265, 256) Hamming SECDED correction module
//
// Syndrome = received_check XOR computed_check
// If syndrome matches a data position (non-power-of-2, 1..265): single error, correct it
// If syndrome matches a check position (power-of-2): single error in check bit, no data fix
// If syndrome > 265: multi-bit error detected

module secded_correct (
    input  wire [255:0] data_in,
    input  wire [8:0]   check_in,    // Received check bits
    input  wire [8:0]   check_calc,  // Calculated check bits (from secded_parity)
    output wire [255:0] data_out,
    output wire         sec_flag,    // Single error corrected
    output wire         ded_flag     // Double error detected
);

    wire [8:0] syndrome = check_in ^ check_calc;

    // Priority encoder: find position of highest set bit in syndrome
    reg [3:0] highest_bit;
    always @(*) begin
        casez (syndrome)
            9'b1????????: highest_bit = 4'd8;
            9'b01???????: highest_bit = 4'd7;
            9'b001??????: highest_bit = 4'd6;
            9'b0001?????: highest_bit = 4'd5;
            9'b00001????: highest_bit = 4'd4;
            9'b000001???: highest_bit = 4'd3;
            9'b0000001??: highest_bit = 4'd2;
            9'b00000001?: highest_bit = 4'd1;
            9'b000000001: highest_bit = 4'd0;
            default:      highest_bit = 4'd0;
        endcase
    end

    // Power-of-2 detection (check bit error positions)
    wire is_pow2 = |syndrome && ((syndrome & (syndrome - 9'd1)) == 9'd0);

    // Range check: valid single-error positions are 1..265
    wire in_range = |syndrome && (syndrome <= 9'd265);

    // Data error: non-zero syndrome in range, not a check bit position
    wire is_data_err = in_range && !is_pow2;

    // Check error: non-zero syndrome in range, at a check bit position
    wire is_check_err = in_range && is_pow2;

    // Convert syndrome (codeword position) to data bit index (0..255)
    // Formula: data_idx = syndrome - 2 - highest_bit_pos
    // (subtracts 1 for zero-indexing and (highest_bit+1) for skipped power-of-2 positions)
    wire [8:0] data_idx = syndrome - {5'd0, highest_bit} - 9'd2;

    // Decomposed one-hot decoder: two 4-to-16 decoders
    wire [15:0] dec_lo = is_data_err ? (16'd1 << data_idx[3:0]) : 16'd0;
    wire [15:0] dec_hi = is_data_err ? (16'd1 << data_idx[7:4]) : 16'd0;

    // 256-bit flip mask from decomposed decoders
    wire [255:0] flip_mask;
    genvar gi, gj;
    generate
        for (gi = 0; gi < 16; gi = gi + 1) begin : gen_hi
            for (gj = 0; gj < 16; gj = gj + 1) begin : gen_lo
                assign flip_mask[gi * 16 + gj] = dec_hi[gi] & dec_lo[gj];
            end
        end
    endgenerate

    assign data_out = data_in ^ flip_mask;

    // SEC: any correctable single-bit error (data or check bit)
    assign sec_flag = is_data_err || is_check_err;

    // DED: non-zero syndrome outside valid range (multi-bit error)
    assign ded_flag = |syndrome && !in_range;

endmodule
"""

if __name__ == "__main__":
    data_to_pos = generate_mapping()
    masks = compute_masks(data_to_pos)

    # Print summary
    print(f"Data bit 0   -> position {data_to_pos[0]}")
    print(f"Data bit 255 -> position {data_to_pos[255]}")
    for j in range(9):
        popcount = bin(masks[j]).count('1')
        print(f"Check bit {j} (pos {1<<j:3d}): covers {popcount} data bits")

    # Generate Verilog files
    src_dir = os.path.join(os.path.dirname(__file__), "..", "src")

    parity_path = os.path.join(src_dir, "secded_parity.v")
    with open(parity_path, "w") as f:
        f.write(gen_secded_parity_v(masks))
    print(f"\nGenerated {parity_path}")

    correct_path = os.path.join(src_dir, "secded_correct.v")
    with open(correct_path, "w") as f:
        f.write(gen_secded_correct_v())
    print(f"Generated {correct_path}")
